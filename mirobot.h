#ifndef MIROBOT_H
#define MIROBOT_H
#include "stdio.h"
#include <unistd.h>
#include "wiringPi.h"
#include "wiringSerial.h"
#include <string>
#include <iostream>
#include "time.h"
#include <cstdlib>
#include <regex>
#include <fstream>


using namespace std;

string doubleToString(double &dbNum);
void getMatch(std::string instr,double data[]);

struct MirobotJoint
{
    int Joint1 = 1;
    int Joint2 = 2;
    int Joint3 = 3;
    int Joint4 = 4;
    int Joint5 = 5;
    int Joint6 = 6;
};
struct RevolveDirection
{
    int cw = 1;
    int ccw = 2;
};
struct MoveDirection
{
    int dforward = 1;
    int dbackward = 2;
    int dup = 3;
    int ddown = 4;
    int dright = 5;
    int dleft = 6;
};
struct MoveMode
{
    int relative = 1; //闂傚倸鍊搁崐鐑芥嚄閸洖纾块柣銏⑶归悿鐐節闂堟稒宸濆ù鐘崇娣囧﹪鎮欓鍕ㄥ亾閺嶎灐娲晝閸屾氨鐛ュ┑掳鍊曢幊搴ｇ不椤栫偞鐓曟繛鎴濆船瀵箖鏌涘顒夊剶闁哄本鐩俊鐑藉閳╁啰褰嗛梻浣筋嚙濞寸兘骞忛敓锟�91
    int absolute = 2; //缂傚倸鍊搁崐鎼佸磹閹间礁纾归柣鎴ｅГ閸婂潡鏌ㄩ弮鍌氫壕鐎规洘鐓￠弻娑樼暆閳ь剟宕曢幇鏉挎瀬閻庯綆鍋佹禍婊堟煛閸愩劍鎼愮悮姘節濞堝灝鐏犳い鏇ㄥ弮閸┾偓妞ゆ巻鍋撶紒鐘茬Ч瀹曟洟宕￠悘缁樻そ婵℃悂鍩℃担绋挎濠电偞鎸婚悢顒勫箯閿燂拷90
};
struct Motion
{
    int MOVJ = 1;//闂傚倸鍊搁崐鐑芥嚄閼哥數浠氱紓鍌欒兌缁垶宕濆▎鎾崇畺闁秆勵殔閻愬﹪鏌曟繛鍨偓妤冪不濮橆剦娓婚柕鍫濇鐏忕敻鏌涢悩鍐插缂佸倸绉规俊鑸靛緞鐎ｎ剙骞嶉梻鍌欑贰閸欏繒绮婚幋鐐存珷妞ゆ梻鍋撻崑鏍煥閻曞倹瀚�
    int MOVL = 2;//闂傚倸鍊搁崐鐑芥嚄閸洖纾块柣銏⑶归悿鐐箾閹存瑥鐒洪柡浣割儐閵囧嫰骞橀崡鐐典患闂佸憡鑹剧紞濠囩嵁閺嶎灔搴敆閳ь剟鎮橀鍔界懓鈹冮崹顔瑰亾濠靛钃熼柣鏂垮悑閻掍粙鏌ㄩ弴妤€浜炬繝鈷€灞芥灓闁诡噮鍣ｉ弫鎾绘晸閿燂拷
    int JUMP = 3;//闂傚倸鍊搁崐鎼佸磹閹间礁纾归柟闂寸绾惧綊鏌涢锝嗙缂佲偓婢跺备鍋撻崗澶婁壕闂佸憡娲﹂崜娆撳焵椤掑倹鏆慨濠冩そ瀹曞綊顢氶崨顓炲濠电姵顔栭崰妤冨垝閹捐钃熼柡鍥╁枔缁犻箖鏌涢…鎴濇灈妞ゎ剙顦扮换婵嗏枔閸喗鐏堝銈忕畵濞佳囶敋閿濆閱囬柡鍥╁仧閸樻悂姊虹粙鎸庢拱闁煎綊绠栭敐鐐典沪閸撗呯槇濠电偛鐗嗛悘婵嗏枍濞嗘挻鐓欓柛鎴欏€栫€氾拷
};
struct Status
{
    bool moving = false;//闂傚倸鍊搁崐椋庣矆娓氣偓楠炴牠顢曢敂钘変罕闂婎偄娲︾粙鎴犲閸ф鐓忛柛顐ｇ箥濡狙呯磽瀹ュ棛澧柕鍥у楠炲洭宕奸弴鐕佲偓宥夋⒑閹肩偛鈧洟鏁冮鍫濊摕婵炴垶鐭▽顏堟煙椤栧棗鏈ˉ锟犳⒒娴ｈ姤銆冪紒鈧担琛″亾濮橆厽绶叉い顐㈢箲缁绘繂顫濋鍌︾床婵犵數濞€濞佳兾涘☉妯炴帡濮€閿涘嫮鐦堝┑鐐茬墕閻忔繈寮搁悢鍏肩厵妞ゆ梻鍘ч埀顒€娼￠幃浼搭敋閳ь剟宕洪埀顒併亜閹烘垵顏柣鎾卞劦閺岋綁寮撮悙娴嬪亾閸︻厸鍋撳鐐
    //闂傚倸鍊搁崐椋庣矆娓氣偓楠炴牠顢曢敂钘変罕闂婎偄娲︾粙鎴犲閸ф鐓忛柛顐ｇ箥濡狙呯磽瀹ュ棛澧柕鍥у楠炲洭宕奸弴鐕佲偓宥夋⒑閹肩偛鈧洟鏁冮鍫濊摕婵炴垶鐭▽顏堟煕閹炬鏈▓褰掓⒒娴ｅ懙褰掓晝閵夆斂鈧啯绻濋崒銈呮闂佸壊鍋呭ú姗€宕愰柨瀣闁割偆鍠庨婊勩亜閵夛附灏い顏勫暣婵¤埖鎯旈垾鑼嚬婵＄偑鍊戦崝灞轿涘┑瀣祦闁糕剝绋戠猾宥夋煕椤愩倕鏋戞繛鍛喘濮婃椽鏌呴悙鑼跺濠⒀勬尦閺屸剝鎷呯憴鍕３閻庢鍣崜鐔镐繆閸洖骞㈡俊銈咃梗缁憋拷
    double A;
    double B;
    double C;
    double D;
    double X;
    double Y;
    double Z;
    //闂傚倸鍊搁崐椋庣矆娓氣偓楠炴牠顢曢敂钘変罕闂婎偄娲︾粙鎴犲閸ф鐓忛柛顐ｇ箥濡狙呯磽瀹ュ棛澧柕鍥у楠炲洭宕奸弴鐕佲偓宥夋⒑閹肩偛鈧洟鏁冮鍫濊摕婵炴垶鐭▽顏堟煕閹炬せ鍋撳┑顔兼搐閳规垿顢欓崗鑹扮闂佺ǹ顑囬崰鎾澄ｉ幇鏉跨婵°倐鍋撶紒顐㈢Ч閺岀喓鈧稒顭囩粻妯好归悪鈧崹浼村煘閹达附鍊烽柤纰卞墮椤も偓闂備焦鎮堕崝宀勬偉婵傚摜宓侀煫鍥ㄧ☉瀹告繃銇勯幘妤€鍟崐顖炴⒒娴ｈ鍋犻柛搴櫍瀵彃饪伴崼鐔封偓鍨亜閹惧崬鐏柍閿嬪灴閺屾稑鈽夊鍫濆闂佹椿鍘奸敃顏堝蓟閵堝悿铏规嫚閼碱兛鍝楅柣搴ゎ潐濞叉﹢銆冩繝鍌ゆ綎闁惧繗顫夌€氭岸鏌嶉妷銉ユ毐闁抽攱娲熷娲偡閺夋寧顔€闂佺懓鍤栭幏锟�
    double CCX;
    double CCY;
    double CCZ;
    double CCRX;
    double CCRY;
    double CCRZ;
    char* time;
    //婵犵數濮烽弫鎼佸磻閻愬搫鍨傞柛顐ｆ礀缁犱即鏌涢锝嗙缁炬崘顫夋穱濠囧Χ閸涱厽娈梺鎼炲妽缁诲嫰鍩€椤掑倹鍤€閻庢凹鍓熼獮妤€效閹惰姤鈷掗柛灞剧懅閸斿秹鏌ｉ鍕Ш鐎规洘绻傞悾婵嬪焵椤掑嫬鐒垫い鎺嶇閸ゎ剟鏌涢幘璺烘灈鐎殿噮鍋婇獮妯兼嫚閸欏妫熼梻渚€娼ч悧鍡椢涘Δ鍜佹晜闁跨噦鎷�
    int PumpPWM;
    int ValvePWM;
};


class Mirobot
{
    private:
        bool debug;
        string port;
        Motion motiontype;
        MoveMode movemode;
        RevolveDirection revolvedirection;
        MirobotJoint mirobotjoint;
        MoveDirection movedirection;
        Status status;
        char time_temp[32];
    public:
    int fd;
    Mirobot(string myport="/dev/ttyUSB0",bool mydebug=false);
    string readline();
    string read_status();
    void get_time();
    //send a message
    void send_msg(string msg,bool wait=false);
    void waitForEnd();
    void dataflush();

    //濠电姷鏁告慨鐢割敊閺嶎厼闂い鏍ㄧ矊缁躲倝鏌ｉ敐鍛拱鐎规洘鐓￠幃妤呮晲鎼粹剝鐏嶉梺缁樻尭閸婂湱鎹㈠┑鍥╃瘈闁稿本鍑规禒鐐節濞堝灝鏋熺紒顔芥崌瀵鍩勯崘銊х獮闁诲函缍嗘禍鐐哄礉缁嬪簱鏀介梽鍥╀焊椤忓牜鏁嬬憸鏂匡耿娓氣偓濮婃椽骞愭惔锝囩暤缂備胶绮崹褰掑焵椤掍胶鍟查柟鍑ゆ嫹
    //home each axis individually
    void home_individual();

    //婵犵數濮烽弫鍛婃叏娴兼潙鍨傞柣鎾崇岸閺嬫牗绻涢幋鐐寸殤闁活厽鎸鹃埀顒冾潐濞叉牕煤閵娧呯焼濠电姴娲﹂悡銉╂煟閺囩偛鈧湱鈧熬鎷�
    //home all axes simultaneously
    void home_simultaneous();

    //闂傚倸鍊峰ù鍥х暦閻㈢ǹ绐楅柟鎵閸嬶繝寮堕崼姘珖缂佲偓婵犲倶鈧帒顫濋敐鍛闁诲孩顔栭崰鎾诲礉閹达箑鏋侀柟鍓х帛閺呮悂鏌ㄩ悤鍌涘
    //unlock the shaft
    void unlock_shaft();

    //闂傚倸鍊峰ù鍥х暦閸偅鍙忛柟鎯板Г閸婂潡鏌ㄩ弴鐐测偓鍝ュ閸ф鐓欓柟顖涙緲琚氶梺绋款儌閺呯娀寮婚敐澶婄疀闂傚牊绋戦～顏呯箾鐎涙ê娈犻柛濠冪箞瀵鎮㈤崗鑲╁姺闂佹寧娲嶉崑鎾愁熆瑜滈崰姘跺箖椤曗偓閹垽宕楃亸鏍ㄥ濠电偞鎸婚懝鎯洪妶鍡欘洸闁绘劗鍎ら悡鏇㈡煟濡搫绾ч柟鐧哥秮閺屽秷顧侀柛鎾寸☉閳诲秹濮€閵堝懐顔嗛梺璺ㄥ櫐閹凤拷
    //set speed
    void set_speed(int speed);

    //闂傚倸鍊搁崐鐑芥嚄閼哥數浠氱紓鍌欒兌缁垶宕濆▎鎾崇畺闁秆勵殔閻愬﹪鏌曟繛鍨偓妤冪不濮橆剦娓婚柕鍫濇鐏忣亪鏌涢妸銉﹁础闁绘碍鍎抽鍏煎緞鐎ｎ亖鍋撻悽鍛婄叆婵犻潧妫濋妤侇殽閻愭惌娈樼紒杈ㄥ笚缁楃喖宕惰閻濇繈姊洪崫鍕拱闁烩晩鍨堕悰顕€骞掑Δ浣糕偓鐑芥煛婢跺鐒惧ù纭锋嫹
    //send all axes to a specific position
    void go_to_axis(double a1,double a2,double a3,double a4,double a5,double a6);

    //闂傚倸鍊搁崐鐑芥倿閿曞倸绠栭柛顐ｆ礀绾惧潡鏌熼幆鐗堫棄缁惧墽绮换娑㈠箣閻愬娈ょ紓浣插亾濠电姴鍊甸弨浠嬫煟濡搫绾у璺哄閺屽秹鏌ㄧ€ｎ剙鈷岄梺鍝勭焿缁绘繂鐣锋總绋款潊闁斥晛鍟惁搴ｇ磽閸屾瑧顦︽い褉鍋撻梺鐟板殩閹凤拷
    //send all axes to their respective zero positions
    void go_to_zero();

    //G1闂傚倸鍊搁崐椋庣矆娓氣偓楠炲鏁撻悩鍐蹭画闂侀潧顦弲娑氬閸︻厽鍠愰柣妤€鐗嗙粭鎺撴叏鐟欏嫮鍙€闁哄矉缍佸顒勫垂椤旇棄鈧垶姊虹紒妯虹瑨妞ゎ厾鍏樺濠氭晲婢跺﹥顥濋梺鍓茬厛閸犳ぞ绨哄┑锛勫亼閸婃牕螞閹达箑绠柨鐕傛嫹
    //G0闂傚倸鍊搁崐椋庣矆娓氣偓楠炴牠顢曢敂钘変罕闂佺粯鍔曢幖顐ょ不椤栨壕鍋撻悷鏉款伃闁稿锕幃銏ゅ幢濞戞瑧鍘卞銈嗗姂閸ㄦ椽藟濠婂嫮绠鹃柡澶嬪灥椤忣厽顨ラ悙鑼闁诡喗绮撻幊鐐哄Ψ閵夈倗鐩庨梺璇叉捣閹虫挾鈧矮鍗冲畷鎴炵節閸パ嗗煘闂佽法鍣﹂幏锟�
    //increment all axes a specified amount
    void increment_axis(double a1,double a2,double a3,double a4,double a5,double a6);

    //缂傚倸鍊搁崐鎼佸磹妞嬪海鐭嗗〒姘ｅ亾閽樻繈鏌熼崜浣烘憘闁轰礁顑囬幉鍛婃償閵娿儳鐤勯梺闈浥堥弲娑㈡偂濞戙垺鐓曟繛鎴濆船楠炴ɑ銇勯敂璇蹭喊婵﹥妞藉畷顐﹀礋閸倣褔鏌ｆ惔锝囨嚄闁告侗鍨抽ˇ顖炴椤愩垺澶勭紒瀣浮閹€斥槈濮橈絽浜炬鐐茬仢閸旀岸鏌熼崘鑼闁诡垰鑻灃闁告劦浜為敍婵嬫倵楠炲灝鍔氶柟鍐茬箻瀹曟娊鎮惧畝鈧壕濂稿级閸稑濡芥い銉ョ墦閺屸剝鎷呯憴鍕３闂佽桨鐒﹂幑鍥极閹剧粯鏅搁柨鐕傛嫹
    //linear move to a cartesian position
    void go_to_cartesian_lin(int m,double x,double y,double z,double a,double b,double c);

    //缂傚倸鍊搁崐鎼佸磹閻戣姤鍊块柨鏇炲€堕埀顒€鍟村畷鍗炩枎閹寸姷鍘梻浣烘嚀閻°劎鎹㈤崟顖氭辈闁挎洖鍊哥痪褔鏌涢锝囶暡婵炲懎鍟撮弻锝夊箳閹搭垵鍚梺鍝勭焿缁绘繂鐣峰鈧俊鎼佸Ψ閵忕姳澹曢梺姹囧灮鏋柡瀣╃窔閺屾盯寮撮妸銉т画闂佹娊鏀辩敮锟犲蓟濞戞矮娌柛鎾楀懐鍘掔紓鍌欒濡狙囧磻閹剧粯鈷掑ù锝呮惈鐢爼鏌ｈ箛鏂垮摵鐎规洖缍婂畷绋课旈埀顒傜不濮樿埖鐓曢柟浼存涧閺嬫稓绱掗埀顒傗偓锝庡亖娴滄粓鏌熼幑鎰【濞寸媴绠撻弻锝夊Χ閸涱喖鏋犲┑顔硷龚濞咃綁骞忛悩璇茬伋闁告劖褰冭ⅸ闂傚倷绀侀幉锟犲礉濡ゅ懎纾婚柟鐐墯閻斿棝鏌￠崘銊у闁抽攱甯掗湁闁挎繂娲ㄩ幗鍌炴煕閵堝拋鍎旈柡宀€鍠栧畷娆撳Χ閸℃浼�
    //linear increment in cartesian space
    void increment_cartesian_lin(int m,double x,double y,double z,double a,double b,double c);

    //闂傚倸鍊搁崐椋庣矆娓氣偓楠炲鏁撻悩鍐叉疄婵°倧绲介崯顐ょ不閻戞绡€濠电姴鍊搁獮妯何旈敃浣圭《闁汇倐鍋撻梻浣烘嚀閻忔繈宕鈶╂灁闁靛ň鏅滈埛鎴︽偣閹帒濡兼繛鍛姍閺岀喖宕欓妶鍡楊伓
    void suction_cup_on();

    //闂傚倸鍊搁崐椋庣矆娓氣偓楠炲鏁撻悩鍐叉疄婵°倧绲介崯顐ょ不閻戞绡€濠电姴鍊搁獮妯何旈敃浣圭《闁汇倐鍋撴繝鐢靛仦閸ㄥ爼鈥﹂崶顑﹀洩顦规慨濠呮閹瑰嫰濡搁妷锔惧綒闂備胶鎳撻崵鏍箯閿燂拷
    void suction_cup_off();

    //闂傚倸鍊搁崐椋庣矆娓氣偓楠炲鏁撻悩鍐叉疄婵°倧绲介崯顐ょ不閻戞绡€濠电姴鍊搁獮妯何旈敃浣圭《闁汇倐鍋撴繝鐢靛仦閸ㄨ埖鐏欓悶姘箞濮婄粯鎷呴懞銉с€婇梺闈╃秶缁犳捇鐛箛娑欐櫢闁跨噦鎷�
    void suction_cup_blow();

    //婵犵數濮烽弫鍛婃叏娴兼潙鍨傞悷娆忓濞呯娀骞栧ǎ顒€濡肩紒鐘靛█閺岀喖骞戦幇闈涙闂佹椿鍘介〃濠囧蓟濞戔懇鈧箓骞嬪┑鍥╁蒋闂備焦鎮堕崐鏍洪悢鐓庤摕闁靛ň鏅滈崑鍡涙煕鐏炲墽鈽夋い蹇ユ嫹
    void gripper_on();

    //婵犵數濮烽弫鍛婃叏娴兼潙鍨傞悷娆忓濞呯娀骞栧ǎ顒€濡肩紒鐘靛█閺岀喖骞戦幇闈涙闂佹椿鍘介〃濠囧蓟濞戞粠妲煎銈冨妼閹虫劗鍒掗崼銉ョ＜闁绘劕顕崣鍡涙⒑缂佹ɑ绀€闁稿﹤婀遍埀顒佺啲閹凤拷
    void gripper_off();

    //set the pwm of the air pump
    void set_air_pump(int pwm);

    // set the pwm of the gripper
    void set_gripper(int pwm);

    //闂傚倷娴囬褍霉閻戣棄纾婚柨婵嗩槸绾捐绻涢幋娆忕仼闁哄嫨鍎甸弻鈥崇暤椤斿吋婀伴悗闈涚焸濮婅櫣绮欑捄銊т紘闂佺ǹ顑嗙粙鎾跺垝婵犳艾唯鐟滃酣宕伴幇鐗堢厵閺夊牊宕樼粈瀣煃瑜滈崗娑氭濮樿泛鏋侀柟鍓х帛閺呮悂鏌ㄩ悤鍌涘 缂傚倸鍊搁崐鎼佸磹妞嬪海鐭嗗〒姘ｅ亾缁℃捇鏌嶈閸撶喖寮婚悢鐓庣闁靛牆妫楅锟�
    //set the pwm of the gripper
    void set_delay_time(int t);

    //濠电姷鏁告慨鐑藉极閸涘﹥鍙忛柟缁㈠枟閺呮繈鏌曟径鍡樻珔闁搞劌鍊块弻锝夊箻閸愯尙妲伴梺鎼炲€曢悧鎾诲蓟瑜戠粻娑㈠箻绾惧顢呴梻浣规た閸樹粙骞戦崶顒€绠栫憸鐗堝笒閻愬﹪鏌曟繛鍨姢缂佷胶鍏橀幃璺侯潩閸楃偞鐏堝┑顔硷攻濡炶棄鐣烽妸锔剧瘈闁稿瞼鍋涘▓婵嬫⒒娴ｇ儤鍤€闁搞倖鐗犻獮蹇涙晸閿燂拷
    void slider_move_to(double x,int speed);

    //婵犵數濮烽弫鎼佸磻閻斿澶愬箛閺夎法锛涢梺褰掑亰閸樺墽绮绘ィ鍐╃厓鐟滄粓宕滈悢鐓庤摕闁靛ň鏅滈崑鍕磼鐎ｎ厽纭跺ù婊勫缁辨挻鎷呴幓鎺嶅濠电偞鎸婚崺鍐磻閹剧粯鐓欐い鏃囧吹閻瑦銇勯姀鈩冪濠碘€崇埣瀹曞爼鍩￠崘銊ヨ劘闂傚倷娴囧畷鍨叏閺夋嚚娲晝娴ｅ吀姹楅梺鍛婂姦閸欏酣寮舵禒瀣拻闁稿本鐟чˇ锕傛煙鐠囇呯？闁轰緡鍣ｉ、鏃堝醇濠靛牜鍞甸梻浣芥硶閸ｏ箓骞忛敓锟�
    void conveyor_move_to(int c,double n,int speed);

    //闂傚倸鍊搁崐鐑芥嚄閼哥數浠氱紓鍌欒兌缁垶宕濆▎鎾崇畺闁秆勵殔閻愬﹪鏌曟繛鍨偓妤冪不濮橆剦娓婚柕鍫濇鐏忛潧鈹戦鎯у幋闁诡垰鐭傞獮妯肩磼濡桨鍖栭梻浣规偠閸庮垶宕濆畝鈧濠囨嚒閵堝棗浠忛梺璺ㄥ櫐閹凤拷
    void move_to_axis(int joint,int revolve,double n);

    //闂傚倸鍊峰ù鍥敋瑜嶉～婵嬫晝閸岋妇绋忔繝銏ｅ煐閸旀牠宕电仦杞挎棃鏁愰崨顓熸缂備胶濮甸悧妤冩崲濠靛洨绡€闁稿本绋戝▍褔姊哄ú璇插箺闁圭懓娲獮鍐亹閹烘垹鍊為梺闈浨归崕宕囩矈閻戣姤鍋犳慨妯煎亾鐎氾拷
    void direction_mobility(int d,double n);

    //闂傚倸鍊搁崐鎼佸磹閹间礁纾归柟闂寸绾惧綊鏌涢锝嗙缂佲偓婢跺备鍋撻崗澶婁壕闂佸憡娲﹂崜娆撳焵椤掑倹鏆慨濠冩そ瀹曞綊顢氶崨顓炲濠电姵顔栭崰妤冨垝閹捐钃熼柡鍥╁枔缁犻箖鏌涢…鎴濇灈妞ゎ剙顦扮换婵嗏枔閸喗鐏堝銈忕畳娴滎剙危閹版澘绠抽柟鎯х－缁愮偤鏌熼崗鍏煎剹闁哥姵鐗曢埢鎾活敇閻旇櫣鐦堝┑鐐茬墕閻忔繂鈻嶅▎鎾寸厵闁告垯鍊栫€氾拷 闂傚倸鍊搁崐椋庣矆娓氣偓楠炲鏁撻悩鍐蹭画濡炪倖鐗楃粙鎾汇€呴弻銉︾厽闁归偊鍓氶幆鍫ユ煛鐎ｂ晝绐旈柡灞炬礋瀹曠厧鈹戦崶鑸碉骏婵＄偑鍊愰弲婊堟偂閿熺姷宓侀柡宥冨妽缂嶅洭鏌涢幘妤€瀚禒褰掓⒒娴ｄ警鏀版繛鍛礋閵嗗啯绻濋崶褑鎽曞┑鐐村灦閿曗晛銆掓繝姘厽闁瑰瓨姊瑰▍鍛瑰⿰鍐ㄢ挃闁逞屽墲椤煤閺嶎灐娲晝閸屾稑鍓ㄩ柣鐘叉处缁佹挳寮ㄦ禒瀣厓闁芥ê顦伴ˉ婊堟煟韫囨梻鎳囬柡灞界Х椤т線鏌涢幘瀵告噮濠㈣娲熼、姗€鎮╅崘鎻掑箲闂備線鈧偛绉电€氾拷
    void jump_move(int m,double x,double y,double z,double a,double b,double c);

    void set_arc_move(int mode,int revolve,double x,double y,double z,double r);

    void get_status();

    ~Mirobot();

};

void mirobot_reset(Mirobot &m);

#endif // MIROBOT_H
